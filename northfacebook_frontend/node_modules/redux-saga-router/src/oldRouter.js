/* eslint no-console: ["error", { allow: ["error"] }] */
import { call, take } from 'redux-saga/effects';
import buildRouteMatcher from './buildRouteMatcher';
import createHistoryChannel from './createHistoryChannel';

const STATE = {
  INIT: 0,
  LISTEN: 1,
  HANDLE_LOCATION: 2,
  DONE: 3,
};

export default function router(history, routes) {
  const routeMatcher = buildRouteMatcher(routes);

  let state = STATE.INIT;
  let previousState = null;
  let lastMatch = null;
  let historyChannel = null;

  function updateState(newState) {
    previousState = state;
    state = newState;
  }

  function getChannelValue() {
    const value = call(createHistoryChannel, history);

    updateState(STATE.LISTEN);

    return { value, done: false };
  }

  function listenValue(channel) {
    if (channel) {
      historyChannel = channel;
    }

    const value = take(historyChannel);

    updateState(STATE.HANDLE_LOCATION);

    return { value, done: false };
  }

  function handleLocationValue(location) {
    const path = location.pathname;
    const match = routeMatcher.match(path);

    if (match) {
      const value = call(match.action, match.params);

      updateState(STATE.LISTEN);
      lastMatch = match;

      return { value, done: false };
    }

    return listenValue();
  }

  function errorMessageValue(error, message) {
    let finalMessage = `Redux Saga Router: ${message}:\n${error.message}`;

    if ('stack' in error) {
      finalMessage += `\n${error.stack}`;
    }

    const value = call([console, console.error], finalMessage);

    updateState(STATE.LISTEN);

    return { value, done: false };
  }

  function doneValue(value) {
    return {
      value,
      done: true,
    };
  }

  const iterator = {
    name: '',

    next(value) {
      switch (state) {
        case STATE.INIT:
          return getChannelValue();

        case STATE.LISTEN:
          return listenValue(value);

        case STATE.HANDLE_LOCATION:
          return handleLocationValue(value);

        default:
          return doneValue();
      }
    },

    throw(e) {
      switch (previousState) {
        case STATE.HANDLE_LOCATION:
          return errorMessageValue(e, `Unhandled ${e.name} in route "${lastMatch.route}"`);

        case STATE.LISTEN:
          return errorMessageValue(e, `Unexpected ${e.name} while listening for route`);

        default:
          return doneValue();
      }
    },

    return(value) {
      updateState(STATE.DONE);
      return doneValue(value);
    },
  };

  if (typeof Symbol === 'function' && Symbol.iterator) {
    iterator[Symbol.iterator] = () => iterator;
  }

  return iterator;
}
