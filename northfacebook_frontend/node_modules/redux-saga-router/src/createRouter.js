/* eslint no-console: ["error", { allow: ["error"] }] */
import { call, take, spawn, cancel } from 'redux-saga/effects';
import fsmIterator from 'fsm-iterator';
import ruta3 from 'ruta3';
import createHistoryChannel from './createHistoryChannel';

const INIT = 'INIT';
const LISTEN = 'LISTEN';
const HANDLE_LOCATION = 'HANDLE_LOCATION';

export default function createRouter() {
  const routeMatcher = ruta3();
  let historyChannel = null;
  let currentRoute = null;

  function addRoute(path, saga, { runImmediately = true } = {}) {
    routeMatcher.addRoute(path, saga);

    if (runImmediately && currentRoute && !currentRoute.matched && historyChannel) {
      currentRoute.matched = true;
      historyChannel.emitter(currentRoute.location);
    }
  }

  // function addRouteUnderPath(rootPath, path, saga, options) {
  //   const trailingSlashRegex = /\/*$/g;
  //   const finalRootPath = rootPath.replace(trailingSlashRegex, '');
  //   const newPath = `${finalRootPath}/${path}`;

  //   return addRoute(newPath, saga, options);
  // }

  // function addRouteFactory(rootPath) {
  //   return addRouteUnderPath.bind(null, rootPath);
  // }

  function addRoutes(routes) {
    Object.keys(routes).forEach((path) => {
      addRoute(path, routes[path]);
    });
  }

  function router(history, routes = {}) {
    addRoutes(routes);

    let lastMatch = null;
    let lastSaga = null;

    function errorMessageValue(error, message) {
      let finalMessage = `Redux Saga Router: ${message}:\n${error.message}`;

      if ('stack' in error) {
        finalMessage += `\n${error.stack}`;
      }

      return {
        value: call([console, console.error], finalMessage),
        next: LISTEN,
      };
    }

    return fsmIterator(INIT, {
      [INIT]: () => ({
        value: call(createHistoryChannel, history),
        next: LISTEN,
      }),

      [LISTEN](effects) {
        if (effects && !historyChannel) {
          historyChannel = effects;
        }

        if (effects instanceof Array) {
          [lastSaga] = effects;
        }

        return {
          value: take(historyChannel),
          next: HANDLE_LOCATION,
        };
      },

      [HANDLE_LOCATION](location, fsm) {
        const path = location.pathname;
        const match = routeMatcher.match(path);
        const effects = [];

        if (match) {
          lastMatch = match;
          currentRoute = { location, matched: true };
          effects.push(spawn(match.action, match.params));
        } else {
          currentRoute = { location, matched: false };
        }

        if (lastSaga) {
          effects.push(cancel(lastSaga));
        }

        if (effects.length > 0) {
          return {
            value: effects,
            next: LISTEN,
          };
        }

        return fsm[LISTEN]();
      },

      throw(e, fsm) {
        switch (fsm.previousState) {
          case HANDLE_LOCATION:
            return errorMessageValue(e, `Unhandled ${e.name} in route "${lastMatch.route}"`);

          case LISTEN:
            return errorMessageValue(e, `Unexpected ${e.name} while listening for route`);

          default:
            return { done: true };
        }
      },
    });
  }

  router.addRoute = addRoute;
  router.addRoutes = addRoutes;
  // router.addRouteUnderPath = addRouteUnderPath;
  // router.addRouteFactory = addRouteFactory;

  return router;
}
