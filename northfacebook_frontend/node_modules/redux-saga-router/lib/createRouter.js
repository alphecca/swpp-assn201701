'use strict';

exports.__esModule = true;
exports.default = createRouter;

var _effects = require('redux-saga/effects');

var _fsmIterator2 = require('fsm-iterator');

var _fsmIterator3 = _interopRequireDefault(_fsmIterator2);

var _ruta = require('ruta3');

var _ruta2 = _interopRequireDefault(_ruta);

var _createHistoryChannel = require('./createHistoryChannel');

var _createHistoryChannel2 = _interopRequireDefault(_createHistoryChannel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint no-console: ["error", { allow: ["error"] }] */
var INIT = 'INIT';
var LISTEN = 'LISTEN';
var HANDLE_LOCATION = 'HANDLE_LOCATION';

function createRouter() {
  var routeMatcher = (0, _ruta2.default)();
  var historyChannel = null;
  var currentRoute = null;

  function addRoute(path, saga) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$runImmediately = _ref.runImmediately,
        runImmediately = _ref$runImmediately === undefined ? true : _ref$runImmediately;

    routeMatcher.addRoute(path, saga);

    if (runImmediately && currentRoute && !currentRoute.matched && historyChannel) {
      currentRoute.matched = true;
      historyChannel.emitter(currentRoute.location);
    }
  }

  // function addRouteUnderPath(rootPath, path, saga, options) {
  //   const trailingSlashRegex = /\/*$/g;
  //   const finalRootPath = rootPath.replace(trailingSlashRegex, '');
  //   const newPath = `${finalRootPath}/${path}`;

  //   return addRoute(newPath, saga, options);
  // }

  // function addRouteFactory(rootPath) {
  //   return addRouteUnderPath.bind(null, rootPath);
  // }

  function addRoutes(routes) {
    Object.keys(routes).forEach(function (path) {
      addRoute(path, routes[path]);
    });
  }

  function router(history) {
    var _fsmIterator;

    var routes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    addRoutes(routes);

    var lastMatch = null;
    var lastSaga = null;

    function errorMessageValue(error, message) {
      var finalMessage = 'Redux Saga Router: ' + message + ':\n' + error.message;

      if ('stack' in error) {
        finalMessage += '\n' + error.stack;
      }

      return {
        value: (0, _effects.call)([console, console.error], finalMessage),
        next: LISTEN
      };
    }

    return (0, _fsmIterator3.default)(INIT, (_fsmIterator = {}, _fsmIterator[INIT] = function () {
      return {
        value: (0, _effects.call)(_createHistoryChannel2.default, history),
        next: LISTEN
      };
    }, _fsmIterator[LISTEN] = function (effects) {
      if (effects && !historyChannel) {
        historyChannel = effects;
      }

      if (effects instanceof Array) {
        lastSaga = effects[0];
      }

      return {
        value: (0, _effects.take)(historyChannel),
        next: HANDLE_LOCATION
      };
    }, _fsmIterator[HANDLE_LOCATION] = function (location, fsm) {
      var path = location.pathname;
      var match = routeMatcher.match(path);
      var effects = [];

      if (match) {
        lastMatch = match;
        currentRoute = { location: location, matched: true };
        effects.push((0, _effects.spawn)(match.action, match.params));
      } else {
        currentRoute = { location: location, matched: false };
      }

      if (lastSaga) {
        effects.push((0, _effects.cancel)(lastSaga));
      }

      if (effects.length > 0) {
        return {
          value: effects,
          next: LISTEN
        };
      }

      return fsm[LISTEN]();
    }, _fsmIterator.throw = function _throw(e, fsm) {
      switch (fsm.previousState) {
        case HANDLE_LOCATION:
          return errorMessageValue(e, 'Unhandled ' + e.name + ' in route "' + lastMatch.route + '"');

        case LISTEN:
          return errorMessageValue(e, 'Unexpected ' + e.name + ' while listening for route');

        default:
          return { done: true };
      }
    }, _fsmIterator));
  }

  router.addRoute = addRoute;
  router.addRoutes = addRoutes;
  // router.addRouteUnderPath = addRouteUnderPath;
  // router.addRouteFactory = addRouteFactory;

  return router;
}