{
  "_args": [
    [
      {
        "raw": "fsm-iterator@^1.0.0",
        "scope": null,
        "escapedName": "fsm-iterator",
        "name": "fsm-iterator",
        "rawSpec": "^1.0.0",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/home/newspring/newspring/northfacebook_frontend/node_modules/redux-saga-router"
    ]
  ],
  "_from": "fsm-iterator@>=1.0.0 <2.0.0",
  "_id": "fsm-iterator@1.1.0",
  "_inCache": true,
  "_location": "/fsm-iterator",
  "_nodeVersion": "6.10.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/fsm-iterator-1.1.0.tgz_1492203253536_0.39349771081469953"
  },
  "_npmUser": {
    "name": "elpapapollo",
    "email": "elpapapollo@gmail.com"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "fsm-iterator@^1.0.0",
    "scope": null,
    "escapedName": "fsm-iterator",
    "name": "fsm-iterator",
    "rawSpec": "^1.0.0",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/redux-saga-router"
  ],
  "_resolved": "https://registry.npmjs.org/fsm-iterator/-/fsm-iterator-1.1.0.tgz",
  "_shasum": "337de45de19eb205788cf02e3a955ec206760dec",
  "_shrinkwrap": null,
  "_spec": "fsm-iterator@^1.0.0",
  "_where": "/home/newspring/newspring/northfacebook_frontend/node_modules/redux-saga-router",
  "author": {
    "name": "Jeremy Fairbank",
    "email": "elpapapollo@gmail.com",
    "url": "http://jeremyfairbank.com"
  },
  "bugs": {
    "url": "https://github.com/jfairbank/fsm-iterator/issues"
  },
  "dependencies": {},
  "description": "A finite state machine iterator for JavaScript",
  "devDependencies": {
    "babel-cli": "^6.16.0",
    "babel-core": "^6.17.0",
    "babel-eslint": "^7.2.2",
    "babel-jest": "^16.0.0",
    "babel-plugin-transform-object-rest-spread": "^6.16.0",
    "babel-polyfill": "^6.16.0",
    "babel-preset-es2015": "^6.16.0",
    "eslint": "^3.7.1",
    "eslint-config-airbnb-base": "^8.0.0",
    "eslint-import-resolver-node": "^0.2.3",
    "eslint-plugin-import": "^1.16.0",
    "jest": "^16.0.1",
    "rimraf": "^2.5.4"
  },
  "directories": {},
  "dist": {
    "shasum": "337de45de19eb205788cf02e3a955ec206760dec",
    "tarball": "https://registry.npmjs.org/fsm-iterator/-/fsm-iterator-1.1.0.tgz"
  },
  "files": [
    "lib",
    "src"
  ],
  "gitHead": "5db553f453c2f5713d6d6976f01bbddbf1b3f3fd",
  "homepage": "https://github.com/jfairbank/fsm-iterator#readme",
  "keywords": [
    "iterator",
    "iterable",
    "generator",
    "finite state machine",
    "state machine",
    "state",
    "fsm"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "elpapapollo",
      "email": "elpapapollo@gmail.com"
    }
  ],
  "name": "fsm-iterator",
  "optionalDependencies": {},
  "readme": "# fsm-iterator\n\n[![Travis branch](https://img.shields.io/travis/jfairbank/fsm-iterator/master.svg?style=flat-square)](https://travis-ci.org/jfairbank/fsm-iterator)\n[![npm](https://img.shields.io/npm/v/fsm-iterator.svg?style=flat-square)](https://www.npmjs.com/package/fsm-iterator)\n\nA finite state machine iterator for JavaScript.\n\nUse fsm-iterator to implement a finite state machine generator function without\nthe need for generator `function*` syntax. This is a perfect for library authors\nthat need to use generators but don't want to burden their ES5 users with a\ntranspiled generator runtime.\n\n## Install\n\n```\nnpm install --save fsm-iterator\n```\n\n## Usage\n\nThe default export is the `fsmIterator` function. It takes an initial state as\nthe first argument and the state machine as an object literal as the second\nargument. Each key-value pair of your definition is a state and a function to\nhandle that state. States can be strings or symbols.\n\nThe state function takes any value that was passed into the `next` method of the\niterator as the first argument and the finite state machine definition itself as\nthe second argument.  This allows you to act on values passed back into the\n\"generator\" and delegate to other states. The finite state machine argument also\nincludes a `previousState` property if you need to use it.\n\nTo yield a value from your state function return an object literal with the\n`value` property set to the yielded value. To specify the next state to\ntransition to, set the `next` property to the next state. You can end the\niterator by including the `done` property set to `true`. If you don't supply the\n`next` property, then the iterator will stay in the same state. This is fine if\nyou want to loop on one thing, but if you have multiple states, then remember to\nuse the `next` property.\n\nYou may include a `throw` function to handle the `throw` method of the iterator.\nIt takes the thrown error as the first argument and the finite state machine\ndefinition as the second argument. If you don't supply a `throw` function, then\nyour iterator will stop, rethrowing the error.\n\nYou may intercept the iterator's `return` method by supplying a `return`\nfunction that receives the passed-in return value as the first argument and the\nfinite state machine definition as the second argument. You can return your own\nreturn value or keep your iterator returning. This is similar to handling the\n`finally` block in a `try..finally` statement in a ES2015 generator function.\n\n```js\n// ES2015 modules\nimport fsmIterator from 'fsm-iterator';\n\n// ES5 and CJS\nvar fsmIterator = require('fsm-iterator').default;\n\nconst FOO = 'FOO';\nconst BAR = 'BAR';\nconst BAZ = 'BAZ';\n\nconst definition = {\n  [FOO]: () => ({\n    value: 'foo',\n    next: BAR,\n  }),\n\n  [BAR](x) {\n    if (x < 0) {\n      return {\n        value: x / 2,\n        done: true,\n      };\n    }\n\n    return {\n      value: x * 2,\n      next: BAZ,\n    };\n  },\n\n  [BAZ]: (_, fsm) => ({\n    value: `baz : ${fsm.previousState}`,\n    next: FOO,\n  }),\n\n  return(value, fsm) {\n    return {\n      value: 'my own return',\n      done: true,\n    }\n  },\n\n  throw: (e, fsm) => ({\n    value: `${e.message} : ${fsm.previousState}`,\n    next: FOO,\n  }),\n};\n\n// Normal path\nlet iterator = fsmIterator(FOO, definition);\n\niterator.next();    // { value: 'foo', done: false }\niterator.next(21);  // { value: 42, done: false }\niterator.next();    // { value: 'baz : BAR', done: false }\niterator.next();    // { value: 'foo', done: false }\niterator.next(-42); // { value: -21, done: true }\n\n// Throwing\nconst error = new Error('error');\niterator = fsmIterator(FOO, definition);\n\niterator.next();       // { value: 'foo', done: false }\niterator.next(21);     // { value: 42, done: false }\niterator.throw(error); // { value: 'error : BAR', done: false }\niterator.next();       // { value: 'foo', done: false }\n\n// Returning\niterator = fsmIterator(FOO, definition);\n\niterator.next();            // { value: 'foo', done: false }\niterator.next(21);          // { value: 42, done: false }\niterator.return('the end'); // { value: 'my own return', done: true }\n```\n\n#### Equivalent ES2015 Generator\n\nHere is the comparable ES2015 generator for the previous example.\n\n```js\nconst FOO = 'FOO';\nconst BAR = 'BAR';\nconst BAZ = 'BAZ';\n\nfunction* myGenerator() {\n  let currentState = FOO;\n  let previousState = null;\n\n  function setState(newState) {\n    previousState = currentState;\n    currentState = newState;\n  }\n\n  while (true) {\n    try {\n      const x = yield 'foo';\n\n      setState(BAR);\n\n      if (x < 0) {\n        return x / 2;\n      }\n\n      yield x * 2;\n\n      setState(BAZ);\n\n      yield `baz : ${previousState}`;\n\n      setState(FOO);\n    } catch (e) {\n      setState(FOO);\n\n      yield `${e.message} : ${previousState}`;\n    } finally {\n      return 'my own return';\n    }\n  }\n}\n```\n\n#### Another Example\n\nHere is the implementation of the `router` saga from\n[redux-saga-router](https://github.com/jfairbank/redux-saga-router) using\n`fsmIterator`.\n\n```js\nimport { call, take } from 'redux-saga/effects';\nimport fsmIterator from 'fsm-iterator';\nimport buildRouteMatcher from './buildRouteMatcher';\nimport createHistoryChannel from './createHistoryChannel';\n\nconst INIT = 'INIT';\nconst LISTEN = 'LISTEN';\nconst HANDLE_LOCATION = 'HANDLE_LOCATION';\n\nexport default function router(history, routes) {\n  const routeMatcher = buildRouteMatcher(routes);\n  let historyChannel = null;\n  let lastMatch = null;\n\n  function errorMessageValue(error, message) {\n    let finalMessage = `Redux Saga Router: ${message}:\\n${error.message}`;\n\n    if ('stack' in error) {\n      finalMessage += `\\n${error.stack}`;\n    }\n\n    return {\n      value: call([console, console.error], finalMessage),\n      next: LISTEN,\n    };\n  }\n\n  return fsmIterator(INIT, {\n    [INIT]: () => ({\n      value: call(createHistoryChannel, history),\n      next: LISTEN,\n    }),\n\n    [LISTEN](channel) {\n      if (channel) {\n        historyChannel = channel;\n      }\n\n      return {\n        value: take(historyChannel),\n        next: HANDLE_LOCATION,\n      };\n    },\n\n    [HANDLE_LOCATION](location, fsm) {\n      const path = location.pathname;\n      const match = routeMatcher.match(path);\n\n      if (match) {\n        lastMatch = match;\n\n        return {\n          value: call(match.action, match.params),\n          next: LISTEN,\n        };\n      }\n\n      return fsm[LISTEN]();\n    },\n\n    throw(e, fsm) {\n      switch (fsm.previousState) {\n        case HANDLE_LOCATION:\n          return errorMessageValue(e, `Unhandled ${e.name} in route \"${lastMatch.route}\"`);\n\n        case LISTEN:\n          return errorMessageValue(e, `Unexpected ${e.name} while listening for route`);\n\n        default:\n          return { done: true };\n      }\n    },\n  });\n}\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jfairbank/fsm-iterator.git"
  },
  "scripts": {
    "build": "babel src --out-dir lib",
    "clean": "rimraf lib",
    "lint": "eslint src __tests__",
    "prepublish": "npm run clean && npm run build",
    "test": "jest"
  },
  "version": "1.1.0"
}
