'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var Promise = require('promise');

function buildParamsAsQueryString(params) {
  var queryString = [];

  for (var p in params) {
    if (params.hasOwnProperty(p)) {
      queryString.push(p + '=' + params[p]);
    }
  }

  return queryString.length > 0 ? '?' + queryString.join('&') : '';
}

function parseHeaders(headerStrings) {
  var headers = {};
  var regexp = /^([^:]+): (.*)/;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = headerStrings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var headerString = _step.value;

      var match = headerString.match(regexp);
      if (match) {
        headers[match[1].toLowerCase()] = match[2];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return headers;
}

function sendRequest(options) {
  var xhr = new XMLHttpRequest();
  var url = options.url;
  var headers = options.headers;
  var method = options.method;
  var responseType = options.responseType;

  xhr.open(method || 'GET', url, true, options.username, options.password);

  if (method === 'GET') {
    url += buildParamsAsQueryString(options.data);
  }

  var body = options.body || options.data || null;
  if ('json' in options) {
    if (!headers.accept && !headers.Accept) {
      headers.Accept = 'application/json';
    }
    if (method !== 'GET' && method !== 'HEAD') {
      if (!headers['content-type'] && !headers['Content-Type']) {
        headers['Content-Type'] = 'application/json';
      }
      body = JSON.stringify(options.json);
    }
    responseType = responseType || 'json';
  }

  if (headers) {
    for (var key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  }

  if (options.onUploadProgress) {
    xhr.upload.onprogress = function onUploadProgress(e) {
      if (e.lengthComputable) {
        var percentLoaded = Math.round(e.loaded / e.total * 100);
        options.onUploadProgress(percentLoaded);
      }
    };
  }

  if (options.timeout) {
    xhr.timeout = options.timeout;
  }

  if (responseType) {
    xhr.responseType = responseType;
  }

  return new Promise(function (resolve, reject) {
    xhr.onreadystatechange = function () {
      if (xhr.readyState !== 4) return;

      var responseBody = null;
      if (xhr.response) {
        responseBody = xhr.response;
      } else if (xhr.responseType === 'text' || !xhr.responseType) {
        responseBody = xhr.responseText || xhr.responseXML;
      }

      var responseHeaders = xhr.getAllResponseHeaders();
      if (headers !== null) {
        responseHeaders = parseHeaders(responseHeaders.split('\n'));
      }
      var response = {
        body: responseBody,
        headers: responseHeaders,
        method: method,
        statusCode: xhr.status,
        url: url,
        xhr: xhr
      };
      if (xhr.status >= 100 && xhr.status < 400) {
        resolve(response);
      } else {
        reject(response);
      }
    };

    xhr.onerror = reject;

    xhr.send(body);
  }).then(function (response) {
    // this is handled in chrome/ff, but IE is bad and this happens
    var typeIsJSON = response.headers['content-type'].includes('application/json');
    var bodyIsString = typeof response.body === 'string';
    if (typeIsJSON && bodyIsString) {
      response.body = JSON.parse(response.body);
    }
    return response;
  });
}

module.exports = {
  get: function get(url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    options.headers = options.headers || {};

    options.method = 'GET';

    if (typeof url === 'string') {
      options.base = options.base || '';
      options.url = options.base + url;
    }

    return sendRequest(options);
  },

  post: function post(url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    options.headers = options.headers || {};

    if (typeof url === 'string') {
      options.base = options.base || '';
      options.url = options.base + url;
    }

    options.method = 'POST';

    return sendRequest(options);
  },

  send: function send(url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    options.headers = options.headers || {};

    if (typeof url === 'string') {
      options.base = options.base || '';
      options.url = options.base + url;
    }

    return sendRequest(options);
  },

  sendFormData: function sendFormData(url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    options.headers = options.headers || {};

    if (typeof url === 'string') {
      options.base = options.base || '';
      options.url = options.base + url;
    }

    options.method = options.method || 'POST';

    if (_typeof(options.data) === 'object') {
      var formData = new FormData();

      for (var key in options.data) {
        if (options.data.hasOwnProperty(key)) {
          formData.append(key, options.data[key]);
        }
      }

      options.data = formData;
    }

    return sendRequest(options);
  }
};